<beast version='2.0'
       namespace='beast.app.beauti:beast.core:beast.evolution.branchratemodel:beast.evolution.speciation:beast.evolution.tree.coalescent:beast.core.util:beast.evolution.nuc:beast.evolution.operators:beast.evolution.sitemodel:beast.evolution.substitutionmodel:beast.evolution.likelihood:beast.evolution:beast.math.distributions'>
              
    <!-- tree priors -->
    <mergewith point='treePriorTemplatesX'>
        <!-- Yule -->
        <!--
        <subtemplate id='YuleModel' class='beast.evolution.speciation.YuleModel' mainid='YuleModel.t:$(n)'>
<![CDATA[
            <plugin spec='YuleModel' id="YuleModel.t:$(n)" tree='@Tree.t:$(n)'>
                <parameter name='birthDiffRate' id="birthRate.t:$(n)" value='1.0'/>
            </plugin>

            <prior id='YuleBirthRatePrior.t:$(n)' x='@birthRate.t:$(n)'><distr spec="beast.math.distributions.Uniform" lower='0' upper='1000'/></prior>

  		    <scale id='YuleBirthRateScaler.t:$(n)' spec='ScaleOperator' scaleFactor="0.75" weight="3" parameter="@birthRate.t:$(n)"/>
]]>

            <connect srcID='YuleModel.t:$(n)' targetID='prior' inputName='distribution'
                     if='inposterior(YuleModel.t:$(n)) and inposterior(birthRate.t:$(n)) and birthRate.t:$(n)/estimate=true'>Yule
                speciation prior on tree t:$(n)
            </connect>
            <connect srcID='birthRate.t:$(n)' targetID='state' inputName='stateNode'
                     if='inposterior(YuleModel.t:$(n)) and inposterior(Tree.t:$(n)) and inposterior(birthRate.t:$(n)) and birthRate.t:$(n)/estimate=true'/>

            <connect srcID='YuleBirthRatePrior.t:$(n)' targetID='prior' inputName='distribution'
                     if='inposterior(YuleModel.t:$(n)) and inposterior(Tree.t:$(n)) and birthRate.t:$(n)/estimate=true'>
                Yule speciation process birth rate of partition t:$(n)
            </connect>
            <connect srcID='YuleBirthRateScaler.t:$(n)' targetID='mcmc' inputName='operator'
                     if='inposterior(YuleModel.t:$(n)) and inposterior(Tree.t:$(n)) and birthRate.t:$(n)/estimate=true'>
                Scale birth rate of Yule prior of tree t:$(n)
            </connect>

            <connect srcID='YuleModel.t:$(n)' targetID='tracelog' inputName='log'
                     if='inposterior(YuleModel.t:$(n)) and inposterior(Tree.t:$(n)) and birthRate.t:$(n)/estimate=true'/>
            <connect srcID='birthRate.t:$(n)' targetID='tracelog' inputName='log'
                     if='inposterior(YuleModel.t:$(n)) and inposterior(Tree.t:$(n)) and birthRate.t:$(n)/estimate=true'/>

			<connect srcID='birthRate.t:Species' targetID='SBI' inputName='birthRate' if='inposterior(YuleModel.t:Species) and inposterior(birthRate.t:Species)'/>
        </subtemplate>
        -->

       <!-- Birth Death model according to Gernhard'08 -->
       <!--
        <subtemplate id='BirthDeathModel' class='beast.evolution.speciation.BirthDeathGernhard08Model'
                     mainid='BirthDeath.t:$(n)'>
            <![CDATA[
            <distribution id="BirthDeath.t:$(n)" spec="speciation.BirthDeathGernhard08Model" tree='@Tree.t:$(n)'>
                <birthDiffRate spec='parameter.RealParameter' id="BDBirthRate.t:$(n)" value='1' lower='0' upper='10000' />
            	<relativeDeathRate spec='parameter.RealParameter' id="BDDeathRate.t:$(n)" value='0.5' lower='0' upper='1' />
            </distribution>

            <prior id='BirthRatePrior.t:$(n)' x='@BDBirthRate.t:$(n)'><distr spec="beast.math.distributions.Uniform" lower='0' upper='1000'/></prior>
            <prior id='DeathRatePrior.t:$(n)' x='@BDDeathRate.t:$(n)'><distr spec="beast.math.distributions.Uniform" lower='0' upper='1'/></prior>

  		    <scale id='BirthRateScaler.t:$(n)' spec='ScaleOperator' scaleFactor="0.75" weight="3" parameter="@BDBirthRate.t:$(n)"/>
  		    <scale id='DeathRateScaler.t:$(n)' spec='ScaleOperator' scaleFactor="0.75" weight="3" parameter="@BDDeathRate.t:$(n)"/>
]]>

            <connect srcID='BirthDeath.t:$(n)' targetID='prior' inputName='distribution'
                     if='inposterior(BirthDeath.t:$(n)) and inposterior(Tree.t:$(n)) and BDBirthRate.t:$(n)/estimate=true'>
                Birth-Death speciation prior on tree t:$(n)
            </connect>
            <connect srcID='BDBirthRate.t:$(n)' targetID='state' inputName='stateNode'
                     if='inposterior(BirthDeath.t:$(n)) and inposterior(BDBirthRate.t:$(n)) and BDBirthRate.t:$(n)/estimate=true'/>
            <connect srcID='BDDeathRate.t:$(n)' targetID='state' inputName='stateNode'
                     if='inposterior(BirthDeath.t:$(n)) and inposterior(BDDeathRate.t:$(n)) and BDDeathRate.t:$(n)/estimate=true'/>

            <connect srcID='BirthRatePrior.t:$(n)' targetID='prior' inputName='distribution'
                     if='inposterior(BirthDeath.t:$(n)) and inposterior(BDBirthRate.t:$(n)) and BDBirthRate.t:$(n)/estimate=true'>
                Birth-Death speciation process rate of partition t:$(n)
            </connect>
            <connect srcID='DeathRatePrior.t:$(n)' targetID='prior' inputName='distribution'
                     if='inposterior(BirthDeath.t:$(n)) and inposterior(BDDeathRate.t:$(n)) and BDDeathRate.t:$(n)/estimate=true'>
                Death/Birth speciation process relative death rate of partition t:$(n)
            </connect>

            <connect srcID='BirthRateScaler.t:$(n)' targetID='mcmc' inputName='operator'
                     if='inposterior(BirthDeath.t:$(n)) and inposterior(BDBirthRate.t:$(n)) and BDBirthRate.t:$(n)/estimate=true'>
                Scale Death-Birth rate of Yule prior of tree t:$(n)
            </connect>
            <connect srcID='DeathRateScaler.t:$(n)' targetID='mcmc' inputName='operator'
                     if='inposterior(BirthDeath.t:$(n)) and inposterior(BDDeathRate.t:$(n)) and BDDeathRate.t:$(n)/estimate=true'>
                Scale Death/Birth rate of Yule prior of tree t:$(n)
            </connect>

            <connect srcID='BirthDeath.t:$(n)' targetID='tracelog' inputName='log'
                     if='inposterior(BirthDeath.t:$(n)) and inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'/>
            <connect srcID='BDBirthRate.t:$(n)' targetID='tracelog' inputName='log'
                     if='inposterior(BirthDeath.t:$(n)) and inposterior(BDBirthRate.t:$(n)) and BDBirthRate.t:$(n)/estimate=true'/>
            <connect srcID='BDDeathRate.t:$(n)' targetID='tracelog' inputName='log'
                     if='inposterior(BirthDeath.t:$(n)) and inposterior(BDDeathRate.t:$(n)) and BDDeathRate.t:$(n)/estimate=true'/>

			<connect srcID='BDBirthRate.t:Species' targetID='SBI' inputName='birthRate' if='inposterior(BirthDeath.t:Species) and inposterior(BDBirthRate.t:Species)'/>
        </subtemplate>
        -->
        
<!-- BDSIR contemp -->
        <subtemplate id='Phylodynamics: BirthDeathSIR (contemp)' class='beast.phylodynamics.BDSIR' mainid='BDSIRcontemp.t:$(n)'       
suppressInputs='beast.phylodynamics.BDSIR.intervalTimes,
	beast.phylodynamics.BDSIR.birthRate,
	beast.phylodynamics.BDSIR.deathRate,
	beast.phylodynamics.BDSIR.samplingRate,
	beast.phylodynamics.BDSIR.samplingProportion,	
	beast.phylodynamics.BDSIR.contemp,
	beast.phylodynamics.BDSIR.S0,
	beast.phylodynamics.BDSIR.dS,
	beast.phylodynamics.BDSIR.dE,
	beast.phylodynamics.BDSIR.dR,
	beast.phylodynamics.BDSIR.isSeasonal,
	beast.phylodynamics.BDSIR.intervalNumber,
	beast.phylodynamics.BDSIR.tree,
	beast.phylodynamics.BDSIR.checkTreeConsistent,
	beast.phylodynamics.BDSIR.treeIntervals,
	beast.phylodynamics.BDSIR.forceRateChange, 
	beast.phylodynamics.BDSIR.conditionOnSurvival, 
	beast.phylodynamics.BDSIR.reverseTimeArrays,
	beast.phylodynamics.BDSIR.rhoSamplingTimes,
	beast.phylodynamics.BDSIR.deathRateChangeTimes,
	beast.phylodynamics.BDSIR.samplingRateChangeTimes,
	beast.phylodynamics.BDSIR.birthRateTimesRelative,
	beast.phylodynamics.BDSIR.deathRateTimesRelative,
	beast.phylodynamics.BDSIR.samplingRateTimesRelative,
	beast.phylodynamics.BDSIR.birthRateChangeTimes'>
<![CDATA[
<!-- SIR simulator -->
	<SIR spec="beast.phylodynamics.epidemiology.HybridSEIREpidemic" id="SIR.t:$(n)" origin="@originEc.t:$(n)" S0="@S0Ec.t:$(n)" Nt="10000" Nsamples="101" 
				birth="@birthEc.t:$(n)" death="@becomeUninfectiousRateEc.t:$(n)" sampling="@samplingEc.t:$(n)" simulationType="SAL" />
	


<!-- Sequential BDSIR model-->
	<BDSIR spec="beast.phylodynamics.BDSIR" dS="@dS.t:$(n)" dR="@dR.t:$(n)" id="BDSIRcontemp.t:$(n)" tree="@Tree.t:$(n)" contemp="true">
		<parameter name="origin" id="originEc.t:$(n)" value="10" lower="0." upper="1000."/>  	
		<parameter name="S0" id="S0Ec.t:$(n)" value="300000" lower="0" upper="10000000"/> 		
		<parameter name="reproductiveNumber" id="reproductiveNumberEc.t:$(n)" value="2" lower="0." dimension ="1" upper="10"/>
		<parameter name="becomeUninfectiousRate" id="becomeUninfectiousRateEc.t:$(n)" value="1." lower="0." upper="10." dimension ="1"/>
		<parameter name="rho" id="rhoEc.t:$(n)" value="0.1" lower="0." upper="1." dimension ="1"/> 
		<parameter name="samplingProportion" id="samplingEc.t:$(n)" value="0." lower="0." upper="1." dimension ="1"/> 
	</BDSIR>

	<distribution  id='originPriorEc.t:$(n)' x="@originEc.t:$(n)" spec='beast.math.distributions.Prior'>
		<distr spec='beast.math.distributions.Uniform' lower="0." upper="1000."/>
	</distribution>
	<distribution id="S0_priorEc.t:$(n)" spec="beast.math.distributions.Prior" x="@S0Ec.t:$(n)">
		<distr spec="beast.math.distributions.LogNormalDistributionModel" M="8." S="2." offset="0."/>
	</distribution>
	<distribution id="rhoPriorEc.t:$(n)" spec="beast.math.distributions.Prior" x="@rhoEc.t:$(n)">
		<distr spec="beast.math.distributions.Beta" alpha="1." beta="1." offset="0."/>
	</distribution>
	<distribution id="becomeUninfectiousRatePriorEc.t:$(n)" spec="beast.math.distributions.Prior" x="@becomeUninfectiousRateEc.t:$(n)">
		<distr spec='beast.math.distributions.LogNormalDistributionModel' M="0." S="1." offset="0.0" meanInRealSpace="false"/>
	</distribution>
	<distribution id="reproductiveNumberPriorEc.t:$(n)" spec="beast.math.distributions.Prior" x="@reproductiveNumberEc.t:$(n)">
		<distr spec='beast.math.distributions.LogNormalDistributionModel' M="0." S="1.25" offset="0.0" meanInRealSpace="false"/>
	</distribution>

	<RPNcalculator spec="beast.math.statistic.RPNcalculator" id="birthEc.t:$(n)" expression="reproductiveNumberEc.t:$(n) S0Ec.t:$(n) / becomeUninfectiousRateEc.t:$(n) *"> 
		<parameter idref="becomeUninfectiousRateEc.t:$(n)"/>
		<parameter idref="reproductiveNumberEc.t:$(n)"/>        
		<parameter idref="S0Ec.t:$(n)"/>        
	</RPNcalculator>

	<parameter name="dS" id="dS.t:$(n)" value="0" dimension="100"/>
	<parameter name="dR" id="dR.t:$(n)" value="0" dimension="100"/>		

    <plate var='p' range='origin,rho,becomeUninfectiousRate,reproductiveNumber,S0'>

		<operator spec="beast.phylodynamics.epidemiology.CompoundSIROperator" id="SIR_$(p)_operatorEc.t:$(n)"  weight="3" tree="@Tree.t:$(n)" origin='@originEc.t:$(n)' birth="@birthEc.t:$(n)" death="@becomeUninfectiousRateEc.t:$(n)" sampling="@samplingEc.t:$(n)" S0="@S0Ec.t:$(n)" dS="@dS.t:$(n)" dR="@dR.t:$(n)">
			<SIR idref="SIR.t:$(n)"/>
			<affectingOperator id='$(p)OperatorEc.t:$(n)' spec='ScaleOperator' scaleFactor=".9" weight="1" parameter="@$(p)Ec.t:$(n)"/>
		</operator> 
	</plate>

		<operator spec="beast.phylodynamics.epidemiology.CompoundSIROperator" id="SIR_tree_operator.t:$(n)"  weight="5" tree="@Tree.t:$(n)" origin='@originEc.t:$(n)' birth="@birthEc.t:$(n)" death="@becomeUninfectiousRateEc.t:$(n)" sampling="@samplingEc.t:$(n)" S0="@S0Ec.t:$(n)" dS="@dS.t:$(n)" dR="@dR.t:$(n)">
			<SIR idref="SIR.t:$(n)"/>
			<affectingOperator spec='ScaleOperator' scaleFactor=".9" weight="5" tree="@Tree.t:$(n)"/>
		</operator> 
	
		<operator spec="beast.phylodynamics.epidemiology.CompoundSIROperator" id="SIR_treeRoot_operator.t:$(n)"  weight="5" tree="@Tree.t:$(n)" origin='@originEc.t:$(n)' birth="@birthEc.t:$(n)" death="@becomeUninfectiousRateEc.t:$(n)" sampling="@samplingEc.t:$(n)" S0="@S0Ec.t:$(n)" dS="@dS.t:$(n)" dR="@dR.t:$(n)">
			<SIR idref="SIR.t:$(n)"/>
			<affectingOperator spec='ScaleOperator' scaleFactor=".9" weight="1" rootOnly="true" tree="@Tree.t:$(n)"/>
		</operator> 
	
		<operator spec="beast.phylodynamics.epidemiology.CompoundSIROperator" id="SIR_subtreeslide_operator.t:$(n)"  weight="15" tree="@Tree.t:$(n)" origin='@originEc.t:$(n)' birth="@birthEc.t:$(n)" death="@becomeUninfectiousRateEc.t:$(n)" sampling="@samplingEc.t:$(n)" S0="@S0Ec.t:$(n)" dS="@dS.t:$(n)" dR="@dR.t:$(n)">
			<SIR idref="SIR.t:$(n)"/>
            <affectingOperator spec='SubtreeSlide' weight="1" gaussian="true" size="1.0" tree="@Tree.t:$(n)"/>
		</operator> 
	
	
]]>

            
            <connect srcID='BDSIRcontemp.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BDSIRcontemp.t:$(n)) and inlikelihood(Tree.t:$(n))'/>

            <connect srcID='origRootPriorEc.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BDSIRcontemp.t:$(n)) and originEc.t:$(n)/estimate=true'>prior on originEc.t:$(n)</connect>
            <connect srcID='S0_priorEc.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BDSIRcontemp.t:$(n)) and S0Ec.t:$(n)/estimate=true'>prior on S0Ec.t:$(n)</connect>
            <connect srcID='rhoPriorEc.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BDSIRcontemp.t:$(n)) and rhoEc.t:$(n)/estimate=true'>prior on rhoEc.t:$(n)</connect>
            <connect srcID='becomeUninfectiousRatePriorEc.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BDSIRcontemp.t:$(n)) and becomeUninfectiousRateEc.t:$(n)/estimate=true'>prior on becomeUninfectiousRateEc.t:$(n)</connect>
            <connect srcID='reproductiveNumberPriorEc.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BDSIRcontemp.t:$(n)) and reproductiveNumberEc.t:$(n)/estimate=true'>prior on reproductiveNumberEc.t:$(n)</connect>


            <connect srcID='BDSIR_contempUniformOperator.t:$(n)'           targetID='mcmc' inputName='operator' if='inposterior(BDSIRcontemp.t:$(n)) and inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Draws new internal node heights uniformally for tree t:$(n)</connect>
            <connect srcID='BDSIR_contempSubtreeSlide.t:$(n)'              targetID='mcmc' inputName='operator' if='inposterior(BDSIRcontemp.t:$(n)) and inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Performs subtree slide rearrangement of tree t:$(n)</connect>
            <connect srcID='BDSIR_contempnarrow.t:$(n)'                    targetID='mcmc' inputName='operator' if='inposterior(BDSIRcontemp.t:$(n)) and inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Narrow exchange performs local rearrangement of tree t:$(n)</connect>
            <connect srcID='BDSIR_contempwide.t:$(n)'                      targetID='mcmc' inputName='operator' if='inposterior(BDSIRcontemp.t:$(n)) and inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Wide exchange performs global rearrangement of tree t:$(n)</connect>
            <connect srcID='BDSIR_contempWilsonBalding.t:$(n)'             targetID='mcmc' inputName='operator' if='inposterior(BDSIRcontemp.t:$(n)) and inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Performs Wilson-Balding global rearrangement of tree t:$(n)</connect>

    <plate var='p' range='origin,rho,becomeUninfectiousRate,reproductiveNumber,S0'>

            <connect srcID='SIR_$(p)_operatorEc.t:$(n)' targetID='mcmc' inputName='operator'     if='inposterior(BDSIRcontemp.t:$(n)) and $(p)Ec.t:$(n)/estimate=true'/>

    </plate>

            <connect srcID='BDSIRcontemp.t:$(n)' targetID='tracelog' inputName='log' if='inposterior(BDSIRcontemp.t:$(n))'/>
            <plate var='p' range='origin,rho,sampling,becomeUninfectiousRate,reproductiveNumber,S0'>
                    <connect srcID='$(p)Ec.t:$(n)' targetID='state' inputName='stateNode' if='inposterior(BDSIRcontemp.t:$(n)) and $(p)Ec.t:$(n)/estimate=true'/>
                    <connect srcID='$(p)Ec.t:$(n)' targetID='tracelog' inputName='log' if='inposterior(BDSIRcontemp.t:$(n)) and $(p)Ec.t:$(n)/estimate=true'/>
            </plate>
            <plate var='p' range='dS,dR'>
                    <connect srcID='$(p).t:$(n)' targetID='state' inputName='stateNode' if='inposterior(BDSIRcontemp.t:$(n))'/>
			</plate>
            <plate var='p' range='birth,dS,dR'>
	            <connect srcID='$(p).t:$(n)' targetID='tracelog' inputName='log' if='inposterior(BDSIRcontemp.t:$(n))'/>
			</plate>
	</subtemplate>







<!-- BDSIR Serial -->
        <subtemplate id='Phylodynamics: BirthDeathSIR (serial)' class='beast.phylodynamics.BDSIR' mainid='BDSIRserial.t:$(n)'       
suppressInputs='beast.phylodynamics.BDSIR.intervalTimes,
	beast.phylodynamics.BDSIR.birthRate,
	beast.phylodynamics.BDSIR.deathRate,
	beast.phylodynamics.BDSIR.samplingRate,
	beast.phylodynamics.BDSIR.rho,
	beast.phylodynamics.BDSIR.contemp,
	beast.phylodynamics.BDSIR.S0,
	beast.phylodynamics.BDSIR.dS,
	beast.phylodynamics.BDSIR.dE,
	beast.phylodynamics.BDSIR.dR,
	beast.phylodynamics.BDSIR.isSeasonal,
	beast.phylodynamics.BDSIR.intervalNumber,
	beast.phylodynamics.BDSIR.tree,
	beast.phylodynamics.BDSIR.checkTreeConsistent,
	beast.phylodynamics.BDSIR.treeIntervals,
	beast.phylodynamics.BDSIR.forceRateChange, 
	beast.phylodynamics.BDSIR.conditionOnSurvival, 
	beast.phylodynamics.BDSIR.reverseTimeArrays,
	beast.phylodynamics.BDSIR.rhoSamplingTimes,
	beast.phylodynamics.BDSIR.deathRateChangeTimes,
	beast.phylodynamics.BDSIR.samplingRateChangeTimes,
	beast.phylodynamics.BDSIR.birthRateTimesRelative,
	beast.phylodynamics.BDSIR.deathRateTimesRelative,
	beast.phylodynamics.BDSIR.samplingRateTimesRelative,
	beast.phylodynamics.BDSIR.birthRateChangeTimes'>
<![CDATA[
<!-- SIR simulator -->
	<SIR spec="beast.phylodynamics.epidemiology.HybridSEIREpidemic" id="SIRserial.t:$(n)" origin="@originEs.t:$(n)" S0="@S0Es.t:$(n)" Nt="10000" Nsamples="101" 
				birth="@birthEs.t:$(n)" death="@deathEs.t:$(n)" sampling="@samplingEs.t:$(n)" simulationType="SAL" />
	
<!-- Sequential BDSIR model-->
	<BDSIR spec="beast.phylodynamics.BDSIR" dS="@dSEs.t:$(n)" dR="@dREs.t:$(n)" id="BDSIRserial.t:$(n)" tree="@Tree.t:$(n)">
		<parameter name="origin" id="originEs.t:$(n)" value="10" lower="0." upper="1000."/>  	
		<parameter name="S0" id="S0Es.t:$(n)" value="300000" lower="0" upper="10000000"/> 		
		<parameter name="reproductiveNumber" id="reproductiveNumberEs.t:$(n)" value="2" lower="0." dimension ="1" upper="10"/>
		<parameter name="becomeUninfectiousRate" id="becomeUninfectiousRateEs.t:$(n)" value="1." lower="0." upper="10." dimension ="1"/>
		<parameter name="samplingProportion" id="samplingProportionEs.t:$(n)" value="0.1" lower="0." upper="1." dimension ="1"/> 
	</BDSIR>

	<distribution  id='originPriorEs.t:$(n)' x="@originEs.t:$(n)" spec='beast.math.distributions.Prior'>
		<distr spec='beast.math.distributions.Uniform' lower="0." upper="1000."/>
	</distribution>
	<distribution id="S0_priorEs.t:$(n)" spec="beast.math.distributions.Prior" x="@S0Es.t:$(n)">
		<distr spec="beast.math.distributions.LogNormalDistributionModel" M="8." S="2." offset="0."/>
	</distribution>
	<distribution id="samplingProportionPriorEs.t:$(n)" spec="beast.math.distributions.Prior" x="@samplingProportionEs.t:$(n)">
		<distr spec="beast.math.distributions.Beta" alpha="1." beta="1." offset="0."/>
	</distribution>
	<distribution id="becomeUninfectiousRatePriorEs.t:$(n)" spec="beast.math.distributions.Prior" x="@becomeUninfectiousRateEs.t:$(n)">
		<distr spec='beast.math.distributions.LogNormalDistributionModel' M="0." S="1." offset="0.0" meanInRealSpace="false"/>
	</distribution>
	<distribution id="reproductiveNumberPriorEs.t:$(n)" spec="beast.math.distributions.Prior" x="@reproductiveNumberEs.t:$(n)">
		<distr spec='beast.math.distributions.LogNormalDistributionModel' M="0." S="1.25" offset="0.0" meanInRealSpace="false"/>
	</distribution>

	<RPNcalculator spec="beast.math.statistic.RPNcalculator" id="birthEs.t:$(n)" expression="reproductiveNumberEs.t:$(n) S0Es.t:$(n) / becomeUninfectiousRateEs.t:$(n) *"> 
		<parameter idref="becomeUninfectiousRateEs.t:$(n)"/>
		<parameter idref="reproductiveNumberEs.t:$(n)"/>        
		<parameter idref="S0Es.t:$(n)"/>        
	</RPNcalculator>
	<RPNcalculator spec="beast.math.statistic.RPNcalculator" id="samplingEs.t:$(n)" expression="becomeUninfectiousRateEs.t:$(n) samplingProportionEs.t:$(n) *"> 
		<parameter idref="becomeUninfectiousRateEs.t:$(n)"/>
		<parameter idref="samplingProportionEs.t:$(n)"/>        
	</RPNcalculator>
	<RPNcalculator spec="beast.math.statistic.RPNcalculator" id="deathEs.t:$(n)" expression="becomeUninfectiousRateEs.t:$(n) 1 samplingProportionEs.t:$(n) - *"> 
		<parameter idref="becomeUninfectiousRateEs.t:$(n)"/>
		<parameter idref="samplingProportionEs.t:$(n)"/>        
	</RPNcalculator>

			<parameter name="dS" id="dSEs.t:$(n)" value="0" dimension="100"/>
			<parameter name="dR" id="dREs.t:$(n)" value="0" dimension="100"/>		

    <plate var='p' range='origin,samplingProportion,becomeUninfectiousRate,reproductiveNumber,S0'>

		<operator spec="beast.phylodynamics.epidemiology.CompoundSIROperator" id="SIR_$(p)_operatorEs.t:$(n)"  weight="3" tree="@Tree.t:$(n)" origin='@originEs.t:$(n)' birth="@birthEs.t:$(n)" death="@deathEs.t:$(n)" sampling="@samplingEs.t:$(n)" S0="@S0Es.t:$(n)" dS="@dSEs.t:$(n)" dR="@dREs.t:$(n)">
			<SIR idref="SIRserial.t:$(n)"/>
			<affectingOperator id='$(p)OperatorEs.t:$(n)' spec='ScaleOperator' scaleFactor=".9" weight="1" parameter="@$(p)Es.t:$(n)"/>
		</operator> 
	</plate>
	
		<operator spec="beast.phylodynamics.epidemiology.CompoundSIROperator" id="SIR_tree_operatorEs.t:$(n)"  weight="5" tree="@Tree.t:$(n)" origin='@originEs.t:$(n)' birth="@birthEs.t:$(n)" death="@deathEs.t:$(n)" sampling="@samplingEs.t:$(n)" S0="@S0Es.t:$(n)" dS="@dSEs.t:$(n)" dR="@dREs.t:$(n)">
			<SIR idref="SIRserial.t:$(n)"/>
			<affectingOperator spec='ScaleOperator' scaleFactor=".9" weight="5" tree="@Tree.t:$(n)"/>
		</operator> 

]]>
            <connect srcID='BDSIRserial.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BDSIRserial.t:$(n)) and inlikelihood(Tree.t:$(n))'/>
            <connect srcID='originPriorEs.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BDSIRserial.t:$(n)) and originEs.t:$(n)/estimate=true'>prior on originEs.t:$(n)</connect>
            <connect srcID='S0_priorEs.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BDSIRserial.t:$(n)) and S0Es.t:$(n)/estimate=true'>prior on S0Es.t:$(n)</connect>
            <connect srcID='samplingProportionPriorEs.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BDSIRserial.t:$(n)) and samplingProportionEs.t:$(n)/estimate=true'>prior on samplingProportionEs.t:$(n)</connect>
            <connect srcID='becomeUninfectiousRatePriorEs.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BDSIRserial.t:$(n)) and becomeUninfectiousRateEs.t:$(n)/estimate=true'>prior over becomeUninfectiousRateEs.t:$(n)</connect>
            <connect srcID='reproductiveNumberPriorEs.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BDSIRserial.t:$(n)) and reproductiveNumberEs.t:$(n)/estimate=true'>prior on reproductiveNumberEs.t:$(n)</connect>

    <plate var='p' range='origin,samplingProportion,becomeUninfectiousRate,reproductiveNumber,S0'>

            <connect srcID='SIR_$(p)_operatorEs.t:$(n)' targetID='mcmc' inputName='operator'     if='inposterior(BDSIRserial.t:$(n)) and $(p)Es.t:$(n)/estimate=true'/>

    </plate>

            <connect srcID='BDSIRserial.t:$(n)' targetID='tracelog' inputName='log' if='inposterior(BDSIRserial.t:$(n))'/>
            <plate var='p' range='origin,samplingProportion,becomeUninfectiousRate,reproductiveNumber,S0,dS,dR'>
                    <connect srcID='$(p)Es.t:$(n)' targetID='state' inputName='stateNode' if='inposterior(BDSIRserial.t:$(n)) and $(p)Es.t:$(n)/estimate=true'/>
                    <connect srcID='$(p)Es.t:$(n)' targetID='tracelog' inputName='log' if='inposterior(BDSIRserial.t:$(n)) and $(p)Es.t:$(n)/estimate=true'/>
            </plate>
            <plate var='p' range='birth,death,sampling'>
	            <connect srcID='$(p)Es.t:$(n)' targetID='tracelog' inputName='log' if='inposterior(BDSIRserial.t:$(n))'/>
			</plate>
	</subtemplate>



<!-- BDSKY contemporary -->
        <subtemplate id='BirthDeathSkylineContemporary' class='beast.evolution.speciation.BirthDeathSkylineModel' mainid='BirthDeathSkyContemporary.t:$(n)'
suppressInputs='beast.evolution.speciation.BirthDeathSkylineModel.intervalTimes,
	beast.evolution.speciation.BirthDeathSkylineModel.birthRate,
	beast.evolution.speciation.BirthDeathSkylineModel.deathRate,
	beast.evolution.speciation.BirthDeathSkylineModel.samplingRate,
	beast.evolution.speciation.BirthDeathSkylineModel.rho,
	beast.evolution.speciation.BirthDeathSkylineModel.contemp,
	beast.evolution.speciation.BirthDeathSkylineModel.S0,
	beast.evolution.speciation.BirthDeathSkylineModel.tree,
	beast.evolution.speciation.BirthDeathSkylineModel.treeIntervals,
	beast.evolution.speciation.BirthDeathSkylineModel.forceRateChange, 
	beast.evolution.speciation.BirthDeathSkylineModel.conditionOnSurvival, 
	beast.math.distributions.MarkovChainDistribution.parameter,
	beast.evolution.speciation.BirthDeathSkylineModel.birthRateTimesRelative,
	beast.evolution.speciation.BirthDeathSkylineModel.deathRateTimesRelative,
	beast.evolution.speciation.BirthDeathSkylineModel.samplingRateTimesRelative,
	beast.evolution.speciation.BirthDeathSkylineModel.reverseTimeArrays,
	beast.evolution.speciation.BirthDeathSkylineModel.originIsRootEdge,
	beast.evolution.speciation.BirthDeathSkylineModel.rhoSamplingTimes,
	beast.evolution.speciation.BirthDeathSkylineModel.deathRateChangeTimes,
	beast.evolution.speciation.BirthDeathSkylineModel.samplingRateChangeTimes,
	beast.evolution.speciation.BirthDeathSkylineModel.birthRateChangeTimes,
	beast.evolution.speciation.BirthDeathSkylineModel.removalProbabilityChangeTimes,
	beast.evolution.speciation.BirthDeathSkylineModel.removalProbability,
	beast.evolution.speciation.BirthDeathSkylineModel.turnOver,
	beast.evolution.speciation.BirthDeathSkylineModel.netDiversification,
	beast.evolution.speciation.BirthDeathSkylineModel.conditionOnRhoSampling'>
<![CDATA[
<!-- Sequential Birth Death Skyline model, with rho for contemp samples -->
	<BirthDeathSkylineModel spec="beast.evolution.speciation.BirthDeathSkylineModel" id="BirthDeathSkyContemporary.t:$(n)" tree="@Tree.t:$(n)">
		<parameter name="origin" id="origin.t:$(n)" value ="1000" lower="0." upper="Infinity"/>  	
		<parameter name="reproductiveNumber" id="reproductiveNumber.t:$(n)" value="2" lower="0." dimension ="10" upper="Infinity"/>
		<parameter name="becomeUninfectiousRate" id="becomeUninfectiousRate.t:$(n)" value="1." lower="0." upper="Infinity" dimension ="1"/>
		<parameter name="samplingProportion" id="samplingProportion.t:$(n)" value="0."/> 
		<parameter name="rho" id="rho.t:$(n)" value="0.01" lower="0." upper="1."/> 
	</BirthDeathSkylineModel>

	<distribution  id='originPriorContemp.t:$(n)' x="@origin.t:$(n)" spec='beast.math.distributions.Prior'>
		<distr spec='beast.math.distributions.Uniform' lower="0." upper="Infinity"/>	</distribution>
	<distribution id="rhoPriorContemp.t:$(n)" spec="beast.math.distributions.Prior" x="@rho.t:$(n)">
		<distr spec="beast.math.distributions.Beta" offset="0.">
			<parameter name="alpha" value="1." estimate="false"/> 
			<parameter name="beta" value="1." estimate="false"/> 
		</distr>	
	</distribution>
	<distribution id="becomeUninfectiousRatePriorContemp.t:$(n)" spec="beast.math.distributions.Prior" x="@becomeUninfectiousRate.t:$(n)">
		<distr spec='beast.math.distributions.LogNormalDistributionModel' offset="0.0" meanInRealSpace="false">
			<parameter name="M" value="0." estimate="false"/> 
			<parameter name="S" value="1." estimate="false"/> 
		</distr>	
	</distribution>
	<distribution id="reproductiveNumberPriorContemp.t:$(n)" spec="beast.math.distributions.Prior" x="@reproductiveNumber.t:$(n)">
		<distr spec='beast.math.distributions.LogNormalDistributionModel' offset="0.0" meanInRealSpace="false">
			<parameter name="M" value="0." estimate="false"/> 
			<parameter name="S" value="1." estimate="false"/> 
		</distr>	
	</distribution>

	<RPNcalculator spec="beast.math.statistic.RPNcalculator" id="birth.t:$(n)" expression="reproductiveNumber.t:$(n) becomeUninfectiousRate.t:$(n) *"> <!-- s/(d+s) -->
		<parameter idref="becomeUninfectiousRate.t:$(n)"/>
		<parameter idref="reproductiveNumber.t:$(n)"/>        
	</RPNcalculator>
	<RPNcalculator spec="beast.math.statistic.RPNcalculator" id="sampling.t:$(n)" expression="becomeUninfectiousRate.t:$(n) samplingProportion.t:$(n) *"> 
		<parameter idref="becomeUninfectiousRate.t:$(n)"/>
		<parameter idref="samplingProportion.t:$(n)"/>        
	</RPNcalculator>
	<RPNcalculator spec="beast.math.statistic.RPNcalculator" id="death.t:$(n)" expression="becomeUninfectiousRate.t:$(n) 1 samplingProportion.t:$(n) - *"> <!-- b*S0/(d+s) -->
		<parameter idref="becomeUninfectiousRate.t:$(n)"/>
		<parameter idref="samplingProportion.t:$(n)"/>        
	</RPNcalculator>

	<!-- BDSKY operators -->
	<operator id='becomeUninfectiousRateScaler.t:$(n)' spec='ScaleOperator' scaleFactor=".75" weight="2" parameter="@becomeUninfectiousRate.t:$(n)"/>
	<operator id='rhoScaler.t:$(n)' spec='ScaleOperator' scaleFactor=".75" weight="1" parameter="@rho.t:$(n)"/>
	<operator id='reproductiveNumberScaler.t:$(n)' spec='ScaleOperator' scaleFactor=".75" weight="10" parameter="@reproductiveNumber.t:$(n)"/>

	<operator id="updownBD.t:$(n)" spec="UpDownOperator" scaleFactor=".75" weight="2">
		<up idref="reproductiveNumber.t:$(n)"/>
		<down idref="becomeUninfectiousRate.t:$(n)"/>
	</operator>

	<operator id='origScaler.t:$(n)' spec='ScaleOperator' scaleFactor=".75" weight="1" parameter="@origin.t:$(n)"/>
]]>
            <connect srcID='BirthDeathSkyContemporary.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BirthDeathSkyContemporary.t:$(n)) and inlikelihood(Tree.t:$(n))'/>

            <connect srcID='originPriorContemp.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BirthDeathSkyContemporary.t:$(n)) and origin.t:$(n)/estimate=true'>prior on origin.t:$(n)</connect>
            <connect srcID='rhoPriorContemp.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BirthDeathSkyContemporary.t:$(n)) and rho.t:$(n)/estimate=true'>prior on sampling proportion t:$(n)</connect>
            <connect srcID='becomeUninfectiousRatePriorContemp.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BirthDeathSkyContemporary.t:$(n)) and becomeUninfectiousRate.t:$(n)/estimate=true'>prior on becomeUninfectiousRate.t:$(n)</connect>
            <connect srcID='reproductiveNumberPriorContemp.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BirthDeathSkyContemporary.t:$(n)) and reproductiveNumber.t:$(n)/estimate=true'>prior on reproductiveNumber.t:$(n)</connect>

            <connect srcID='becomeUninfectiousRateScaler.t:$(n)' targetID='mcmc' inputName='operator'     if='inposterior(BirthDeathSkyContemporary.t:$(n)) and becomeUninfectiousRate.t:$(n)/estimate=true'/>
            <connect srcID='rhoScaler.t:$(n)' targetID='mcmc' inputName='operator'     if='inposterior(BirthDeathSkyContemporary.t:$(n)) and rho.t:$(n)/estimate=true'/>
            <connect srcID='reproductiveNumberScaler.t:$(n)' targetID='mcmc' inputName='operator'     if='inposterior(BirthDeathSkyContemporary.t:$(n)) and reproductiveNumber.t:$(n)/estimate=true'/>
            <connect srcID='updownBD.t:$(n)' targetID='mcmc' inputName='operator'     if='inposterior(BirthDeathSkyContemporary.t:$(n)) and reproductiveNumber.t:$(n)/estimate=true and becomeUninfectiousRate.t:$(n)/estimate=true'/>
            <connect srcID='origScaler.t:$(n)' targetID='mcmc' inputName='operator'     if='inposterior(BirthDeathSkyContemporary.t:$(n)) and origin.t:$(n)/estimate=true'/>

            <connect srcID='BirthDeathSkyContemporary.t:$(n)' targetID='tracelog' inputName='log' if='inposterior(BirthDeathSkyContemporary.t:$(n))'/>
            <plate var='p' range='origin,rho,becomeUninfectiousRate,reproductiveNumber'>
                    <connect srcID='$(p).t:$(n)' targetID='state' inputName='stateNode' if='inposterior(BirthDeathSkyContemporary.t:$(n)) and $(p).t:$(n)/estimate=true'/>
                    <connect srcID='$(p).t:$(n)' targetID='tracelog' inputName='log' if='inposterior(BirthDeathSkyContemporary.t:$(n)) and $(p).t:$(n)/estimate=true'/>
            </plate>
            <plate var='p' range='birth,death,sampling'>
	            <connect srcID='$(p).t:$(n)' targetID='tracelog' inputName='log' if='inposterior(BirthDeathSkyContemporary.t:$(n))'/>
			</plate>
	</subtemplate>
  
        
<!-- Sequential Birth Death Skyline model-->

        <subtemplate id='BirthDeathSkylineSerial' class='beast.evolution.speciation.BirthDeathSkylineModel' mainid='BirthDeathSkySerial.t:$(n)'
suppressInputs='beast.evolution.speciation.BirthDeathSkylineModel.intervalTimes,
	beast.evolution.speciation.BirthDeathSkylineModel.birthRate,
	beast.evolution.speciation.BirthDeathSkylineModel.deathRate,
	beast.evolution.speciation.BirthDeathSkylineModel.samplingRate,
	beast.evolution.speciation.BirthDeathSkylineModel.rho,
	beast.evolution.speciation.BirthDeathSkylineModel.contemp,
	beast.evolution.speciation.BirthDeathSkylineModel.S0,
	beast.evolution.speciation.BirthDeathSkylineModel.tree,
	beast.evolution.speciation.BirthDeathSkylineModel.treeIntervals,
	beast.evolution.speciation.BirthDeathSkylineModel.forceRateChange, 
	beast.evolution.speciation.BirthDeathSkylineModel.conditionOnSurvival, 
	beast.math.distributions.MarkovChainDistribution.parameter,
	beast.evolution.speciation.BirthDeathSkylineModel.reverseTimeArrays,
	beast.evolution.speciation.BirthDeathSkylineModel.originIsRootEdge,
	beast.evolution.speciation.BirthDeathSkylineModel.rhoSamplingTimes,
	beast.evolution.speciation.BirthDeathSkylineModel.deathRateChangeTimes,
	beast.evolution.speciation.BirthDeathSkylineModel.samplingRateChangeTimes,
	beast.evolution.speciation.BirthDeathSkylineModel.birthRateTimesRelative,
	beast.evolution.speciation.BirthDeathSkylineModel.deathRateTimesRelative,
	beast.evolution.speciation.BirthDeathSkylineModel.samplingRateTimesRelative,
	beast.evolution.speciation.BirthDeathSkylineModel.birthRateChangeTimes,
	beast.evolution.speciation.BirthDeathSkylineModel.removalProbabilityChangeTimes,
	beast.evolution.speciation.BirthDeathSkylineModel.removalProbability,
	beast.evolution.speciation.BirthDeathSkylineModel.turnOver,
	beast.evolution.speciation.BirthDeathSkylineModel.netDiversification,
	beast.evolution.speciation.BirthDeathSkylineModel.conditionOnRhoSampling'>
<![CDATA[
<!-- Sequential Birth Death Skyline model-->
	<BirthDeathSkylineModel spec="beast.evolution.speciation.BirthDeathSkylineModel" id="BirthDeathSkySerial.t:$(n)" tree="@Tree.t:$(n)">
		<parameter name="origin" id="origin.t:$(n)" value ="1000" lower="0." upper="Infinity"/>  	
		<parameter name="reproductiveNumber" id="reproductiveNumber.t:$(n)" value="2" lower="0." dimension ="10" upper="Infinity"/>
		<parameter name="becomeUninfectiousRate" id="becomeUninfectiousRate.t:$(n)" value="1." lower="0." upper="Infinity" dimension ="1"/>
		<parameter name="samplingProportion" id="samplingProportion.t:$(n)" value="0.01" lower="0." upper="1." dimension ="1"/> 
	</BirthDeathSkylineModel>
	<distribution  id='originPrior.t:$(n)' x="@origin.t:$(n)" spec='beast.math.distributions.Prior'>
		<distr spec='beast.math.distributions.Uniform' lower="0." upper="Infinity"/>
	</distribution>
	<distribution id="samplingProportionPrior.t:$(n)" spec="beast.math.distributions.Prior" x="@samplingProportion.t:$(n)">
		<distr spec="beast.math.distributions.Beta" offset="0.">
			<parameter name="alpha" value="1." estimate="false"/> 
			<parameter name="beta" value="1." estimate="false"/> 
		</distr>		
	</distribution>
	<distribution id="becomeUninfectiousRatePrior.t:$(n)" spec="beast.math.distributions.Prior" x="@becomeUninfectiousRate.t:$(n)">
		<distr spec='beast.math.distributions.LogNormalDistributionModel' offset="0.0" meanInRealSpace="false">
			<parameter name="M" value="0." estimate="false"/> 
			<parameter name="S" value="1." estimate="false"/> 
		</distr>	
	</distribution>
	<distribution id="reproductiveNumberPrior.t:$(n)" spec="beast.math.distributions.Prior" x="@reproductiveNumber.t:$(n)">
		<distr spec='beast.math.distributions.LogNormalDistributionModel' offset="0.0" meanInRealSpace="false">
			<parameter name="M" value="0." estimate="false"/> 
			<parameter name="S" value="1." estimate="false"/> 
		</distr>	
	</distribution>
	<RPNcalculator spec="beast.math.statistic.RPNcalculator" id="birth.t:$(n)" expression="reproductiveNumber.t:$(n) becomeUninfectiousRate.t:$(n) *"> <!-- s/(d+s) -->
		<parameter idref="becomeUninfectiousRate.t:$(n)"/>
		<parameter idref="reproductiveNumber.t:$(n)"/>        
	</RPNcalculator>
	<RPNcalculator spec="beast.math.statistic.RPNcalculator" id="sampling.t:$(n)" expression="becomeUninfectiousRate.t:$(n) samplingProportion.t:$(n) *"> 
		<parameter idref="becomeUninfectiousRate.t:$(n)"/>
		<parameter idref="samplingProportion.t:$(n)"/>        
	</RPNcalculator>
	<RPNcalculator spec="beast.math.statistic.RPNcalculator" id="death.t:$(n)" expression="becomeUninfectiousRate.t:$(n) 1 samplingProportion.t:$(n) - *"> <!-- b*S0/(d+s) -->
		<parameter idref="becomeUninfectiousRate.t:$(n)"/>
		<parameter idref="samplingProportion.t:$(n)"/>        
	</RPNcalculator>

	<!-- BDSKY operators -->
	<operator id='becomeUninfectiousRateScaler.t:$(n)' spec='ScaleOperator' scaleFactor=".75" weight="2" parameter="@becomeUninfectiousRate.t:$(n)"/>
	<operator id='samplingScaler.t:$(n)' spec='ScaleOperator' scaleFactor=".75" weight="2" parameter="@samplingProportion.t:$(n)"/>
	<operator id='reproductiveNumberScaler.t:$(n)' spec='ScaleOperator' scaleFactor=".75" weight="10" parameter="@reproductiveNumber.t:$(n)"/>
	<operator id="updownBD.t:$(n)" spec="UpDownOperator" scaleFactor=".75" weight="2">
		<up idref="reproductiveNumber.t:$(n)"/>
		<down idref="becomeUninfectiousRate.t:$(n)"/>
	</operator>
	<operator id='origScaler.t:$(n)' spec='ScaleOperator' scaleFactor=".75" weight="1" parameter="@origin.t:$(n)"/>
]]>
            <connect srcID='BirthDeathSkySerial.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BirthDeathSkySerial.t:$(n)) and inlikelihood(Tree.t:$(n))'/>

            <connect srcID='originPrior.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BirthDeathSkySerial.t:$(n)) and origin.t:$(n)/estimate=true'>prior on origin.t:$(n)</connect>
            <connect srcID='samplingProportionPrior.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BirthDeathSkySerial.t:$(n)) and samplingProportion.t:$(n)/estimate=true'>prior on sampling proportion t:$(n)</connect>
            <connect srcID='becomeUninfectiousRatePrior.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BirthDeathSkySerial.t:$(n)) and becomeUninfectiousRate.t:$(n)/estimate=true'>prior on becomeUninfectiousRate.t:$(n)</connect>
            <connect srcID='reproductiveNumberPrior.t:$(n)' targetID='prior' inputName='distribution' if='inposterior(BirthDeathSkySerial.t:$(n)) and reproductiveNumber.t:$(n)/estimate=true'>prior on reproductiveNumber.t:$(n)</connect>

            <connect srcID='becomeUninfectiousRateScaler.t:$(n)' targetID='mcmc' inputName='operator'     if='inposterior(BirthDeathSkySerial.t:$(n)) and becomeUninfectiousRate.t:$(n)/estimate=true'/>
            <connect srcID='samplingScaler.t:$(n)' targetID='mcmc' inputName='operator'     if='inposterior(BirthDeathSkySerial.t:$(n)) and samplingProportion.t:$(n)/estimate=true'/>
            <connect srcID='reproductiveNumberScaler.t:$(n)' targetID='mcmc' inputName='operator'     if='inposterior(BirthDeathSkySerial.t:$(n)) and reproductiveNumber.t:$(n)/estimate=true'/>
            <connect srcID='updownBD.t:$(n)' targetID='mcmc' inputName='operator'     if='inposterior(BirthDeathSkySerial.t:$(n)) and reproductiveNumber.t:$(n)/estimate=true and becomeUninfectiousRate.t:$(n)/estimate=true'/>
            <connect srcID='origScaler.t:$(n)' targetID='mcmc' inputName='operator'     if='inposterior(BirthDeathSkySerial.t:$(n)) and origin.t:$(n)/estimate=true'/>

            
            <plate var='p' range='origin,samplingProportion,becomeUninfectiousRate,reproductiveNumber'>
                    <connect srcID='$(p).t:$(n)' targetID='state' inputName='stateNode' if='inposterior(BirthDeathSkySerial.t:$(n)) and $(p).t:$(n)/estimate=true'/>
                    <connect srcID='$(p).t:$(n)' targetID='tracelog' inputName='log' if='inposterior(BirthDeathSkySerial.t:$(n)) and $(p).t:$(n)/estimate=true'/>
            </plate>
            <plate var='p' range='birth,death,sampling'>
	            <connect srcID='$(p).t:$(n)' targetID='tracelog' inputName='log' if='inposterior(BirthDeathSkySerial.t:$(n))'/>
			</plate>
			
	</subtemplate>


        <!-- Coalescent for Constant population -->
        <subtemplate id='CoalescentConstantPopulation' class='beast.evolution.tree.coalescent.Coalescent'
                     mainid='CoalescentConstant.t:$(n)'>
            <![CDATA[
            <distribution id="CoalescentConstant.t:$(n)" spec="Coalescent">
                <treeIntervals spec='TreeIntervals' id='TreeIntervals.t:$(n)' tree='@Tree.t:$(n)'/>
                <populationModel spec="ConstantPopulation" id='ConstantPopulation.t:$(n)'>
                     <parameter name="popSize" id="popSize.t:$(n)" value='0.3' estimate='true'/>
                 </populationModel>
            </distribution>

  		    <operator id='PopSizeScaler.t:$(n)' spec='ScaleOperator' scaleFactor="0.75" weight="3" parameter="@popSize.t:$(n)"/>
	        <prior id='PopSizePrior.t:$(n)' x='@popSize.t:$(n)'><distr spec="OneOnX"/></prior>
]]>

            <connect srcID='CoalescentConstant.t:$(n)' targetID='prior' inputName='distribution'
                     if='inposterior(CoalescentConstant.t:$(n))'>Coalescent prior with
                constant rate on tree t:$(n)
            </connect>
            <connect srcID='PopSizePrior.t:$(n)' targetID='prior' inputName='distribution'
                     if='inposterior(CoalescentConstant.t:$(n)) and inposterior(popSize.t:$(n)) and popSize.t:$(n)/estimate=true'>
                Coalescent population size parameter of partition t:$(n)
            </connect>

            <connect srcID='popSize.t:$(n)' targetID='state' inputName='stateNode'
                     if='inposterior(CoalescentConstant.t:$(n)) and inposterior(popSize.t:$(n)) and popSize.t:$(n)/estimate=true'/>

            <connect srcID='PopSizeScaler.t:$(n)' targetID='mcmc' inputName='operator'
                     if='inposterior(CoalescentConstant.t:$(n)) and inposterior(popSize.t:$(n)) and popSize.t:$(n)/estimate=true'>
                Scale population size of Coalescent prior of tree t:$(n)
            </connect>

            <connect srcID='popSize.t:$(n)' targetID='tracelog' inputName='log'
                     if='inposterior(CoalescentConstant.t:$(n)) and inposterior(popSize.t:$(n)) and popSize.t:$(n)/estimate=true'/>
            <connect srcID='CoalescentConstant.t:$(n)' targetID='tracelog' inputName='log'
                     if='inposterior(CoalescentConstant.t:$(n))'/>
        </subtemplate>


        <!-- Coalescent for Exponential population -->
        <subtemplate id='CoalescentExponentialPopulation' class='beast.evolution.tree.coalescent.Coalescent'
                     mainid='CoalescentExponential.t:$(n)'>
            <![CDATA[
            <distribution id="CoalescentExponential.t:$(n)" spec="Coalescent">
                <treeIntervals spec='TreeIntervals' id='TreeIntervals.t:$(n)' tree='@Tree.t:$(n)'/>
                <populationModel spec="ExponentialGrowth" id="ExponentialGrowth.t:$(n)">
                    <parameter name="popSize" id="ePopSize.t:$(n)" value='0.3' estimate='true'/>
                    <parameter name="growthRate" id="growthRate.t:$(n)" value='3e-4' estimate='true'/>
                </populationModel>
            </distribution>

  		    <operator id='ePopSizeScaler.t:$(n)' spec='ScaleOperator' scaleFactor="0.75" weight="3" parameter="@ePopSize.t:$(n)"/>
	        <operator id="GrowthRateRandomWalk.t:$(n)" spec="RealRandomWalkOperator" windowSize='1' weight="3" parameter="@growthRate.t:$(n)"/>

	        <prior id='ePopSizePrior.t:$(n)' x='@ePopSize.t:$(n)'><distr spec="OneOnX"/></prior>
	        <prior id='GrowthRatePrior.t:$(n)' x='@growthRate.t:$(n)'><distr spec="LaplaceDistribution"><parameter name="mu" value='0.001' estimate="false"/><parameter name="scale" value='30.701135' estimate="false"/></distr></prior>

]]>

            <connect srcID='CoalescentExponential.t:$(n)' targetID='prior' inputName='distribution'
                     if='inposterior(CoalescentExponential.t:$(n))'>Coalesenct prior with
                exponential rate on tree t:$(n)
            </connect>
            <connect srcID='ePopSizePrior.t:$(n)' targetID='prior' inputName='distribution'
                     if='inposterior(CoalescentExponential.t:$(n)) and inposterior(ePopSize.t:$(n)) and ePopSize.t:$(n)/estimate=true'>
                Coalescent population size parameter of partition t:$(n)
            </connect>
            <connect srcID='GrowthRatePrior.t:$(n)' targetID='prior' inputName='distribution'
                     if='inposterior(CoalescentExponential.t:$(n)) and inposterior(growthRate.t:$(n)) and growthRate.t:$(n)/estimate=true'>
                Coalescent growth rate of partition t:$(n)
            </connect>

            <connect srcID='ePopSize.t:$(n)' targetID='state' inputName='stateNode'
                     if='inposterior(CoalescentExponential.t:$(n)) and inposterior(ePopSize.t:$(n))  and ePopSize.t:$(n)/estimate=true'/>
            <connect srcID='growthRate.t:$(n)' targetID='state' inputName='stateNode'
                     if='inposterior(CoalescentExponential.t:$(n)) and inposterior(growthRate.t:$(n)) and growthRate.t:$(n)/estimate=true'/>

            <connect srcID='ePopSizeScaler.t:$(n)' targetID='mcmc' inputName='operator'
                     if='inposterior(CoalescentExponential.t:$(n)) and inposterior(ePopSize.t:$(n))  and ePopSize.t:$(n)/estimate=true'>
                Scale population size of Coalescent prior of tree t:$(n)
            </connect>
            <connect srcID='GrowthRateRandomWalk.t:$(n)' targetID='mcmc' inputName='operator'
                     if='inposterior(CoalescentExponential.t:$(n)) and inposterior(growthRate.t:$(n)) and growthRate.t:$(n)/estimate=true'>
                Scale growth rate of Coalescent prior of tree t:$(n)
            </connect>

            <connect srcID='CoalescentExponential.t:$(n)' targetID='tracelog' inputName='log'
                     if='inposterior(CoalescentExponential.t:$(n))'/>
            <connect srcID='ePopSize.t:$(n)' targetID='tracelog' inputName='log'
                     if='inposterior(CoalescentExponential.t:$(n)) and inposterior(ePopSize.t:$(n)) and ePopSize.t:$(n)/estimate=true'/>
            <connect srcID='growthRate.t:$(n)' targetID='tracelog' inputName='log'
                     if='inposterior(CoalescentExponential.t:$(n)) and inposterior(growthRate.t:$(n)) and growthRate.t:$(n)/estimate=true'/>
        </subtemplate>

    </mergewith>
</beast>


